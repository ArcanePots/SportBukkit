From 2d8bf31cf61f43ff7354812dbefa70c32b7dfc39 Mon Sep 17 00:00:00 2001
From: Jedediah Smith <jedediah@silencegreys.com>
Date: Wed, 16 Mar 2016 22:09:17 -0400
Subject: [PATCH] Knockback API


diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index 0d3d55b..7a49cf8 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -1205,13 +1205,36 @@ public abstract class Entity implements ICommandListener {
         }
     }
 
-    public void g(double d0, double d1, double d2) {
-        this.motX += d0;
-        this.motY += d1;
-        this.motZ += d2;
+    // SportBukkit start - velocity API
+    public void applyKnockback(Entity attacker, Vec3D impulse, boolean client) {
+        if(impulse != null) {
+            applyKnockback(attacker, impulse.x, impulse.y, impulse.z, client);
+        }
+    }
+
+    public void applyKnockback(Entity attacker, double x, double y, double z, boolean client) {
+        this.applyImpulse(x, y, z, client);
+    }
+
+    public void applyImpulse(double x, double y, double z, boolean client) {
+        setVelocity(this.motX + x, this.motY + y, this.motZ + z);
+    }
+
+    public void setVelocity(double x, double y, double z) {
+        if(x == this.motX && y == this.motY && z == this.motZ) return;
+
+        this.motX = x;
+        this.motY = y;
+        this.motZ = z;
+        this.velocityChanged = true;
         this.impulse = true;
     }
 
+    public void g(double d0, double d1, double d2) {
+        applyImpulse(d0, d1, d2, false);
+    }
+    // SportBukkit end
+
     protected void ao() {
         this.velocityChanged = true;
     }
diff --git a/src/main/java/net/minecraft/server/EntityArrow.java b/src/main/java/net/minecraft/server/EntityArrow.java
index 83a42a0..eceb2cf 100644
--- a/src/main/java/net/minecraft/server/EntityArrow.java
+++ b/src/main/java/net/minecraft/server/EntityArrow.java
@@ -275,7 +275,7 @@ public abstract class EntityArrow extends Entity implements IProjectile {
                         float f1 = MathHelper.sqrt(this.motX * this.motX + this.motZ * this.motZ);
 
                         if (f1 > 0.0F) {
-                            entityliving.g(this.motX * (double) this.knockbackStrength * 0.6000000238418579D / (double) f1, 0.1D, this.motZ * (double) this.knockbackStrength * 0.6000000238418579D / (double) f1);
+                            entityliving.applyKnockback(this, this.motX * (double) this.knockbackStrength * 0.6000000238418579D / (double) f1, 0.1D, this.motZ * (double) this.knockbackStrength * 0.6000000238418579D / (double) f1, false); // SportBukkit - call knockback method
                         }
                     }
 
diff --git a/src/main/java/net/minecraft/server/EntityHuman.java b/src/main/java/net/minecraft/server/EntityHuman.java
index 92766a0..7a6898f 100644
--- a/src/main/java/net/minecraft/server/EntityHuman.java
+++ b/src/main/java/net/minecraft/server/EntityHuman.java
@@ -1045,6 +1045,8 @@ public abstract class EntityHuman extends EntityLiving {
                             this.cH();
                         }
 
+                        // SportBukkit start - disable this entire block
+                        /*
                         if (entity instanceof EntityPlayer && entity.velocityChanged) {
                             // CraftBukkit start - Add Velocity Event
                             boolean cancelled = false;
@@ -1069,6 +1071,8 @@ public abstract class EntityHuman extends EntityLiving {
                             }
                             // CraftBukkit end
                         }
+                        */
+                        // SportBukkit end
 
                         if (flag2) {
                             this.world.a((EntityHuman) null, this.locX, this.locY, this.locZ, SoundEffects.ENTITY_PLAYER_ATTACK_CRIT, this.bz(), 1.0F, 1.0F);
diff --git a/src/main/java/net/minecraft/server/EntityLiving.java b/src/main/java/net/minecraft/server/EntityLiving.java
index 7b9bfc1..7278a96 100644
--- a/src/main/java/net/minecraft/server/EntityLiving.java
+++ b/src/main/java/net/minecraft/server/EntityLiving.java
@@ -899,7 +899,7 @@ public abstract class EntityLiving extends Entity {
                         }
 
                         this.az = (float) (MathHelper.b(d1, d0) * 57.2957763671875D - (double) this.yaw);
-                        this.a(entity, 0.4F, d0, d1);
+                        this.a(damagesource.i(), 0.4F, d0, d1); // SportBukkit - use direct damage source instead of owner
                     } else {
                         this.az = (float) ((int) (Math.random() * 2.0D) * 180);
                     }
@@ -1016,21 +1016,26 @@ public abstract class EntityLiving extends Entity {
 
     public void a(Entity entity, float f, double d0, double d1) {
         if (this.random.nextDouble() >= this.getAttributeInstance(GenericAttributes.c).getValue()) {
-            this.impulse = true;
-            float f1 = MathHelper.sqrt(d0 * d0 + d1 * d1);
-
-            this.motX /= 2.0D;
-            this.motZ /= 2.0D;
-            this.motX -= d0 / (double) f1 * (double) f;
-            this.motZ -= d1 / (double) f1 * (double) f;
-            if (this.onGround) {
-                this.motY /= 2.0D;
-                this.motY += (double) f;
-                if (this.motY > 0.4000000059604645D) {
-                    this.motY = 0.4000000059604645D;
-                }
-            }
-
+            // SportBukkit start
+            final double scale = 1 - getBukkitEntity().getKnockbackReduction();
+            if(scale == 0) return;
+
+            final boolean vertical = onGround || getBukkitEntity().getServer().getVerticalKnockbackOffGround();
+            final double len = MathHelper.sqrt(d0 * d0 + d1 * d1);
+
+            final double
+                dx = (motX / 2 - d0 * f / len) - motX,
+                dy = Math.min(0.4, motY / 2 + f) - motY,
+                dz = (motZ / 2 - d1 * f / len) - motZ;
+
+            applyKnockback(
+                entity,
+                scale * dx,
+                (vertical ? scale * dy : 0),
+                scale * dz,
+                false
+            );
+            // SportBukkit end
         }
     }
 
@@ -2082,9 +2087,13 @@ public abstract class EntityLiving extends Entity {
         return !this.dead && this.collides; // CraftBukkit
     }
 
+    // SportBukkit start - this is not needed
+    /*
     protected void ao() {
         this.velocityChanged = this.random.nextDouble() >= this.getAttributeInstance(GenericAttributes.c).getValue();
     }
+    */
+    // SportBukkit end
 
     public float getHeadRotation() {
         return this.aO;
diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index 335f831..ffc27d0 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -4,10 +4,14 @@ import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import com.mojang.authlib.GameProfile;
 import io.netty.buffer.Unpooled;
+
 import java.util.Collection;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
+
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -20,8 +24,11 @@ import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.event.inventory.InventoryType;
 import org.bukkit.craftbukkit.util.Skins;
+import org.bukkit.event.player.PlayerKnockbackEvent;
 import org.bukkit.event.player.PlayerSkinPartsChangeEvent;
 import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
+import org.bukkit.event.player.PlayerVelocityEvent;
+import org.bukkit.util.Vector;
 // CraftBukkit end
 
 public class EntityPlayer extends EntityHuman implements ICrafting {
@@ -71,6 +78,161 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     public String hostname;
     // CraftBukkit end
 
+    // SportBukkit start - velocity events/prediction
+    private static class ClientImpulse {
+        final long timestamp;
+        final Vector velocity;
+
+        private ClientImpulse(long timestamp, Vector velocity) {
+            this.timestamp = timestamp;
+            this.velocity = velocity;
+        }
+    }
+
+    private Vector unsentImpulse = new Vector();
+    private final Map<Integer, Vector> sentImpulses = new HashMap<Integer, Vector>();
+    private boolean clientVelocityUnacked;
+    private long clientVelocityTimestamp;
+    private final Vector clientVelocity = new Vector();
+    private final Vector clientPosition = new Vector();
+
+    @Override
+    public void applyKnockback(Entity attacker, double x, double y, double z, boolean client) {
+        final PlayerKnockbackEvent event = new PlayerKnockbackEvent(getBukkitEntity(), attacker.getBukkitEntity(), new Vector(x, y, z), true);
+        getBukkitEntity().getServer().getPluginManager().callEvent(event);
+        if(event.isCancelled()) return;
+
+        applyImpulseNoEvent(event.getVelocity(), client);
+    }
+
+    @Override
+    public void applyImpulse(double x, double y, double z, boolean client) {
+        final PlayerVelocityEvent event = new PlayerVelocityEvent(getBukkitEntity(), new Vector(x, y, z), true);
+        getBukkitEntity().getServer().getPluginManager().callEvent(event);
+        if(event.isCancelled()) return;
+
+        applyImpulseNoEvent(event.getVelocity(), client);
+    }
+
+    @Override
+    public void setVelocity(double x, double y, double z) {
+        final PlayerVelocityEvent event = new PlayerVelocityEvent(getBukkitEntity(), new Vector(x, y, z), false);
+        getBukkitEntity().getServer().getPluginManager().callEvent(event);
+        if(event.isCancelled()) return;
+
+        setVelocityNoEvent(event.getVelocity());
+    }
+
+    private void applyImpulseNoEvent(Vector impulse, boolean client) {
+        this.motX += impulse.getX();
+        this.motY += impulse.getY();
+        this.motZ += impulse.getZ();
+
+        if(client) {
+            unsentImpulse.add(impulse);
+            velocityChanged = true;
+        } else {
+            clientVelocity.set(motX, motY, motZ);
+            sendAbsoluteVelocity();
+        }
+    }
+
+    private void setVelocityNoEvent(Vector velocity) {
+        this.motX = velocity.getX();
+        this.motY = velocity.getY();
+        this.motZ = velocity.getZ();
+
+        clientVelocity.set(velocity);
+        sendAbsoluteVelocity();
+    }
+
+    /**
+     * Send the current predicted client velocity back to the client as an absolute
+     * velocity. Set the client velocity timestamp and clear any sent impulses.
+     */
+    private void sendAbsoluteVelocity() {
+        sentImpulses.clear();
+        clientVelocityTimestamp = playerConnection.sendAbsoluteVelocity(clientVelocity);
+        clientVelocityUnacked = true;
+    }
+
+    /**
+     * Send any accumulated velocity changes to the client as an impulse, and reset
+     * the accumulator. Send a keepalive packet immediately before the impulse, and
+     * save the impulse and timestamp together in a queue.
+     */
+    public void sendAccumulatedImpulse() {
+        if(velocityChanged && !unsentImpulse.isZero()) {
+            final int timestamp = playerConnection.sendRelativeVelocity(unsentImpulse);
+            Vector impulse = sentImpulses.get(timestamp);
+            if(impulse != null) {
+                impulse.add(unsentImpulse);
+            } else {
+                sentImpulses.put(timestamp, unsentImpulse);
+            }
+            unsentImpulse = new Vector();
+            velocityChanged = false;
+        }
+    }
+
+    public Vector getClientVelocity() {
+        return clientVelocity;
+    }
+
+    public Vector getUnackedImpulse() {
+        final Vector velocity = new Vector();
+        for(Vector impulse : sentImpulses.values()) {
+            velocity.add(impulse);
+        }
+        return velocity;
+    }
+
+    public boolean hasUnackedVelocity() {
+        return clientVelocityUnacked;
+    }
+
+    /**
+     * Predict the velocity of the player, based on their reported movements,
+     * and any impulses that have been applied but not yet acknowledged.
+     */
+    public Vector getPredictedVelocity() {
+        return getUnackedImpulse().add(clientVelocity);
+    }
+
+    public void handleKeepAlive(int timestamp) {
+        if(clientVelocityTimestamp == timestamp) {
+            clientVelocityUnacked = false;
+        }
+        sentImpulses.remove(timestamp);
+    }
+
+    /**
+     * Called when a position update is received from the client. If position is null,
+     * it is assumed that the client has not moved from their last position.
+     */
+    public void handleClientTick(Vector position, boolean onGround) {
+        if(!clientVelocityUnacked) {
+            // If the last sent absolute velocity has been acknowledged by the client,
+            // then infer the client's velocity based on their last two known positions.
+            if(position == null) {
+                clientVelocity.zero();
+            } else {
+                clientVelocity.set(position).subtract(clientPosition);
+
+                if(!this.playerConnection.clientOnGround && onGround && clientVelocity.getY() > 0) {
+                    // Client moves just under double normal distance in the
+                    // first tick after jumping (reason unknown.. bug?)
+                    clientVelocity.multiply(new Vector(0.5, 1, 0.5));
+                }
+            }
+        }
+
+        if(position != null) {
+            clientPosition.set(position);
+        }
+    }
+    // SportBukkit end
+
     public EntityPlayer(MinecraftServer minecraftserver, WorldServer worldserver, GameProfile gameprofile, PlayerInteractManager playerinteractmanager) {
         super(worldserver, gameprofile);
         playerinteractmanager.player = this;
diff --git a/src/main/java/net/minecraft/server/EntityTrackerEntry.java b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
index 1737342..4cf4ff4 100644
--- a/src/main/java/net/minecraft/server/EntityTrackerEntry.java
+++ b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
@@ -256,6 +256,8 @@ public class EntityTrackerEntry {
 
         ++this.a;
         if (this.tracker.velocityChanged) {
+            // SportBukkit start - send impulse to players, instead of absolute velocity
+            /*
             // CraftBukkit start - Create PlayerVelocity event
             boolean cancelled = false;
 
@@ -277,6 +279,15 @@ public class EntityTrackerEntry {
                 this.broadcastIncludingSelf(new PacketPlayOutEntityVelocity(this.tracker));
             }
             // CraftBukkit end
+            */
+
+            if(this.tracker instanceof EntityPlayer) {
+                ((EntityPlayer) this.tracker).sendAccumulatedImpulse();
+            } else {
+                broadcast(new PacketPlayOutEntityVelocity(this.tracker));
+            }
+            // SportBukkit end
+
             this.tracker.velocityChanged = false;
         }
 
diff --git a/src/main/java/net/minecraft/server/Explosion.java b/src/main/java/net/minecraft/server/Explosion.java
index 69720e8..a10c0b2 100644
--- a/src/main/java/net/minecraft/server/Explosion.java
+++ b/src/main/java/net/minecraft/server/Explosion.java
@@ -141,9 +141,19 @@ public class Explosion {
                             d14 = EnchantmentProtection.a((EntityLiving) entity, d13);
                         }
 
+                        // SportBukkit start
+                        // For non-player entities, call the knockback method instead of directly mutating velocity.
+                        // Don't change player velocity at all, that happens later in WorldServer.createExplosion
+                        /*
                         entity.motX += d8 * d14;
                         entity.motY += d9 * d14;
                         entity.motZ += d10 * d14;
+                        */
+                        if(!(entity instanceof EntityHuman)) {
+                            entity.applyKnockback(source, d8 * d14, d9 * d14, d10 * d14, true);
+                        }
+                        // SportBukkit end
+
                         if (entity instanceof EntityHuman) {
                             EntityHuman entityhuman = (EntityHuman) entity;
 
diff --git a/src/main/java/net/minecraft/server/PlayerConnection.java b/src/main/java/net/minecraft/server/PlayerConnection.java
index bd25271..cd833e5 100644
--- a/src/main/java/net/minecraft/server/PlayerConnection.java
+++ b/src/main/java/net/minecraft/server/PlayerConnection.java
@@ -61,6 +61,7 @@ import org.bukkit.inventory.CraftingInventory;
 import org.bukkit.inventory.EquipmentSlot;
 import org.bukkit.inventory.InventoryView;
 import org.bukkit.util.NumberConversions;
+import org.bukkit.util.Vector;
 // CraftBukkit end
 
 public class PlayerConnection implements PacketListenerPlayIn, ITickable {
@@ -139,6 +140,36 @@ public class PlayerConnection implements PacketListenerPlayIn, ITickable {
     private final static HashSet<Integer> invalidItems = new HashSet<Integer>(java.util.Arrays.asList(8, 9, 10, 11, 26, 34, 36, 43, 51, 52, 55, 59, 60, 62, 63, 64, 68, 71, 74, 75, 83, 90, 92, 93, 94, 104, 105, 115, 117, 118, 119, 125, 127, 132, 140, 141, 142, 144)); // TODO: Check after every update.
     // CraftBukkit end
 
+    // SportBukkit start - velocity prediction
+    public int sendPacketWithTimestamp(Packet<?> packet) {
+        final int timestamp = (int) createKeepAliveTimestamp();
+        sendPacket(new PacketPlayOutKeepAlive(timestamp));
+        sendPacket(packet);
+        return timestamp;
+    }
+
+    public int sendRelativeVelocity(Vector impulse) {
+        return sendPacketWithTimestamp(new PacketPlayOutExplosion(
+            0, -9999, 0, 1,
+            Collections.<BlockPosition>emptyList(),
+            new Vec3D(
+                impulse.getX(),
+                impulse.getY(),
+                impulse.getZ()
+            )
+        ));
+    }
+
+    public int sendAbsoluteVelocity(Vector velocity) {
+        return sendPacketWithTimestamp(new PacketPlayOutEntityVelocity(
+            player.getId(),
+            velocity.getX(),
+            velocity.getY(),
+            velocity.getZ()
+        ));
+    }
+    // SportBukkit end
+
     public void c() {
         this.d();
         this.player.k_();
@@ -464,6 +495,16 @@ public class PlayerConnection implements PacketListenerPlayIn, ITickable {
                     this.d();
                 }
 
+                // SportBukkit start - velocity prediction
+                this.player.handleClientTick(
+                    packetplayinflying.hasPos ? new Vector(packetplayinflying.x,
+                                                           packetplayinflying.y,
+                                                           packetplayinflying.z)
+                                              : null,
+                    packetplayinflying.a()
+                );
+                // SportBukkit end
+
                 if (this.teleportPos != null) {
                     if (this.e - this.A > 20) {
                         this.A = this.e;
@@ -2179,6 +2220,7 @@ public class PlayerConnection implements PacketListenerPlayIn, ITickable {
     }
 
     public void a(PacketPlayInKeepAlive packetplayinkeepalive) {
+        this.player.handleKeepAlive(packetplayinkeepalive.a());
         if (packetplayinkeepalive.a() == this.f) {
             int i = (int) (this.e() - this.g);
 
@@ -2187,6 +2229,7 @@ public class PlayerConnection implements PacketListenerPlayIn, ITickable {
 
     }
 
+    public long createKeepAliveTimestamp() { return this.e(); } // SportBukkit - alias for following method
     private long e() {
         return System.nanoTime() / 1000000L;
     }
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index 6fa82ee..ec88465 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -1176,7 +1176,10 @@ public class WorldServer extends World implements IAsyncTaskHandler {
             EntityHuman entityhuman = (EntityHuman) iterator.next();
 
             if (entityhuman.e(d0, d1, d2) < 4096.0D) {
-                ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutExplosion(d0, d1, d2, f, explosion.getBlocks(), (Vec3D) explosion.b().get(entityhuman)));
+                // SportBukkit start - call knockback method
+                ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutExplosion(d0, d1, d2, f, explosion.getBlocks(), null));
+                entityhuman.applyKnockback(entity, explosion.b().get(entityhuman), true);
+                // SportBukkit end
             }
         }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 04ced31..e265af3 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -624,6 +624,11 @@ public final class CraftServer extends CraftBukkitRuntime implements Server {
     }
 
     @Override
+    public boolean getVerticalKnockbackOffGround() {
+        return this.configuration.getBoolean("settings.vertical-knockback-off-ground", false);
+    }
+
+    @Override
     public boolean getIsolatePlugins() {
         return this.configuration.getBoolean("settings.isolate-plugins", false);
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index b14f11b..6294caf 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -33,6 +33,7 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
     protected final CraftServer server;
     protected Entity entity;
     private EntityDamageEvent lastDamageEvent;
+    private float knockbackReduction;
 
     public CraftEntity(final CraftServer server, final Entity entity) {
         this.server = server;
@@ -207,10 +208,30 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
     }
 
     public void setVelocity(Vector vel) {
-        entity.motX = vel.getX();
-        entity.motY = vel.getY();
-        entity.motZ = vel.getZ();
-        entity.velocityChanged = true;
+        getHandle().setVelocity(vel.getX(), vel.getY(), vel.getZ());
+    }
+
+    @Override
+    public void applyImpulse(Vector impulse) {
+        applyImpulse(impulse, false);
+    }
+
+    @Override
+    public void applyImpulse(Vector impulse, boolean relative) {
+        getHandle().applyImpulse(impulse.getX(),
+                                 impulse.getY(),
+                                 impulse.getZ(),
+                                 relative);
+    }
+
+    @Override
+    public void setKnockbackReduction(float n) {
+        this.knockbackReduction = n;
+    }
+
+    @Override
+    public float getKnockbackReduction() {
+        return this.knockbackReduction;
     }
 
     public boolean isOnGround() {
@@ -668,4 +689,9 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         }
         return perm;
     }
+
+    @Override
+    public Vector getPredictedVelocity() {
+        return getVelocity();
+    }
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index c7f88f5..5d61bff 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -76,6 +76,7 @@ import org.bukkit.plugin.Plugin;
 import org.bukkit.plugin.messaging.StandardMessenger;
 import org.bukkit.scoreboard.Scoreboard;
 import org.bukkit.util.RayBlockIntersection;
+import org.bukkit.util.Vector;
 
 @DelegateDeserialization(CraftOfflinePlayer.class)
 public class CraftPlayer extends CraftHumanEntity implements Player {
@@ -1883,6 +1884,26 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     }
 
     @Override
+    public Vector getPredictedVelocity() {
+        return getHandle().getPredictedVelocity();
+    }
+
+    @Override
+    public Vector getClientVelocity() {
+        return getHandle().getClientVelocity();
+    }
+
+    @Override
+    public Vector getUnackedImpulse() {
+        return getHandle().getUnackedImpulse();
+    }
+
+    @Override
+    public boolean hasUnackedVelocity() {
+        return getHandle().hasUnackedVelocity();
+    }
+
+    @Override
     public boolean teleportRelative(org.bukkit.util.Vector deltaPos, float deltaYaw, float deltaPitch) {
         return teleportRelative(deltaPos, deltaYaw, deltaPitch, PlayerTeleportEvent.TeleportCause.PLUGIN);
     }
-- 
1.9.0

