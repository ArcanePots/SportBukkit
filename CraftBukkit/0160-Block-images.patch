From 0150a2fc654eb35f1457fd018e9eecd82b033f6f Mon Sep 17 00:00:00 2001
From: Jedediah Smith <jedediah@silencegreys.com>
Date: Mon, 10 Oct 2016 04:53:27 -0400
Subject: [PATCH] Block images


diff --git a/src/main/java/net/minecraft/server/BlockPosition.java b/src/main/java/net/minecraft/server/BlockPosition.java
index b241977..b0bfd44 100644
--- a/src/main/java/net/minecraft/server/BlockPosition.java
+++ b/src/main/java/net/minecraft/server/BlockPosition.java
@@ -8,8 +8,93 @@ import javax.annotation.concurrent.Immutable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
+// SportBukkit start - implement Vec3
+import org.bukkit.geometry.MutableVec3;
+import org.bukkit.geometry.MutableVec3Coarse;
+import org.bukkit.geometry.Vec3Coarse;
+import org.bukkit.geometry.Vec3;
+import org.bukkit.util.ImVector;
+
 @Immutable
-public class BlockPosition extends BaseBlockPosition {
+public class BlockPosition extends BaseBlockPosition implements Vec3Coarse<BlockPosition> {
+
+    public static BlockPosition of(int x, int y, int z) {
+        if(x == 0 && y == 0 && z == 0) return ZERO;
+        return new BlockPosition(x, y, z);
+    }
+
+    public static BlockPosition of(Vec3 that) {
+        return that instanceof BlockPosition
+               ? (BlockPosition) that
+               : new BlockPosition(that.coarseX(), that.coarseY(), that.coarseZ());
+    }
+
+    public static BlockPosition copyOf(Vec3 that) {
+        return that instanceof BlockPosition && !that.isMutable()
+               ? (BlockPosition) that
+               : new BlockPosition(that.coarseX(), that.coarseY(), that.coarseZ());
+    }
+
+    @Override
+    public BlockPosition copy() {
+        return this;
+    }
+
+    @Override
+    public MutableVec3 mutableCopy() {
+        return new MutableBlockPosition(this);
+    }
+
+    @Override
+    public Vec3 fineCopy() {
+        return ImVector.cornerOf(this);
+    }
+
+    @Override
+    public Vec3 fineOf(double x, double y, double z) {
+        return ImVector.of(x, y, z);
+    }
+
+    @Override
+    public Vec3 fineZero() {
+        return ImVector.ofZero();
+    }
+
+    @Override
+    public BlockPosition coarseOf(int x, int y, int z) {
+        return new BlockPosition(x, y, z);
+    }
+
+    @Override
+    public BlockPosition coarseZero() {
+        return ZERO;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        return this == obj || (obj instanceof Vec3 && equals((Vec3) obj));
+    }
+
+    @Override
+    public int hashCode() {
+        return coarseHashCode();
+    }
+
+    @Override
+    public int coarseX() {
+        return getX();
+    }
+
+    @Override
+    public int coarseY() {
+        return getY();
+    }
+
+    @Override
+    public int coarseZ() {
+        return getZ();
+    }
+    // SportBukkit end
 
     private static final Logger b = LogManager.getLogger();
     public static final BlockPosition ZERO = new BlockPosition(0, 0, 0);
@@ -321,7 +406,55 @@ public class BlockPosition extends BaseBlockPosition {
         }
     }
 
-    public static class MutableBlockPosition extends BlockPosition {
+    // SportBukkit start - implement MutableVec3
+    public static class MutableBlockPosition extends BlockPosition implements MutableVec3Coarse<BlockPosition, MutableBlockPosition> {
+        @Override
+        public Vec3 unmodifiable() {
+            return new BlockPosition(0, 0, 0) {
+                @Override public BlockPosition copy() {
+                    return MutableBlockPosition.this.copy();
+                }
+
+                @Override public int getX() {
+                    return MutableBlockPosition.this.getX();
+                }
+
+                @Override public int getY() {
+                    return MutableBlockPosition.this.getY();
+                }
+
+                @Override public int getZ() {
+                    return MutableBlockPosition.this.getZ();
+                }
+            };
+        }
+
+        @Override
+        public MutableBlockPosition setX(int x) {
+            this.b = x;
+            return this;
+        }
+
+        @Override
+        public MutableBlockPosition setY(int y) {
+            this.c = y;
+            return this;
+        }
+
+        @Override
+        public MutableBlockPosition setZ(int z) {
+            this.d = z;
+            return this;
+        }
+
+        @Override
+        public MutableBlockPosition set(int x, int y, int z) {
+            this.b = x;
+            this.c = y;
+            this.d = z;
+            return this;
+        }
+        // SportBukkit end
 
         protected int b;
         protected int c;
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index 84a728f..59ca335 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -1723,7 +1723,7 @@ public abstract class Entity implements ICommandListener {
                 if(getBukkitEntity() instanceof Player) {
                     final Player player = (Player) getBukkitEntity();
                     final EntityLocation newLocation = player.getEntityLocation();
-                    newLocation.copy(entity.getBukkitEntity().getLocation());
+                    newLocation.copyLocation(entity.getBukkitEntity().getLocation());
                     CraftEventFactory.callPlayerPoseFlagEvent(player, PoseFlag.RIDING, true, newLocation, event);
                 }
                 CraftEntity craftn = (CraftEntity) getBukkitEntity().getVehicle();
diff --git a/src/main/java/org/bukkit/CraftBukkitRuntime.java b/src/main/java/org/bukkit/CraftBukkitRuntime.java
index 531d9f6..ed4a904 100644
--- a/src/main/java/org/bukkit/CraftBukkitRuntime.java
+++ b/src/main/java/org/bukkit/CraftBukkitRuntime.java
@@ -1,15 +1,17 @@
 package org.bukkit;
 
 import net.minecraft.server.DispenserRegistry;
-import org.bukkit.block.RegionFactory;
-import org.bukkit.craftbukkit.block.CraftRegionFactory;
+import org.bukkit.block.BlockFactory;
+import org.bukkit.craftbukkit.block.CraftBlockFactory;
 import org.bukkit.craftbukkit.inventory.CraftItemFactory;
-import org.bukkit.craftbukkit.potion.CraftPotionEffectRegistry;
 import org.bukkit.craftbukkit.potion.CraftPotionBrewRegistry;
+import org.bukkit.craftbukkit.potion.CraftPotionEffectRegistry;
 import org.bukkit.craftbukkit.registry.CraftKey;
-import org.bukkit.potion.PotionEffectRegistry;
+import org.bukkit.craftbukkit.util.CraftVectorFactory;
 import org.bukkit.potion.PotionBrewRegistry;
+import org.bukkit.potion.PotionEffectRegistry;
 import org.bukkit.registry.Key;
+import org.bukkit.geometry.VectorFactory;
 
 public class CraftBukkitRuntime implements BukkitRuntime {
 
@@ -26,6 +28,9 @@ public class CraftBukkitRuntime implements BukkitRuntime {
         }
     }
 
+    private final CraftBlockFactory blockFactory = new CraftBlockFactory();
+    private final CraftVectorFactory vectorFactory = new CraftVectorFactory();
+
     private final PotionBrewRegistry potionBrewRegistry = new CraftPotionBrewRegistry();
     private final PotionEffectRegistry potionEffectRegistry = new CraftPotionEffectRegistry();
 
@@ -44,13 +49,18 @@ public class CraftBukkitRuntime implements BukkitRuntime {
     }
 
     @Override
-    public CraftItemFactory getItemFactory() {
-        return CraftItemFactory.instance();
+    public BlockFactory blocks() {
+        return blockFactory;
+    }
+
+    @Override
+    public VectorFactory vectors() {
+        return vectorFactory;
     }
 
     @Override
-    public RegionFactory getRegionFactory() {
-        return CraftRegionFactory.instance();
+    public CraftItemFactory getItemFactory() {
+        return CraftItemFactory.instance();
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index a344ef4..36c7d0b 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -1725,11 +1725,6 @@ public final class CraftServer extends CraftBukkitRuntime implements Server {
     }
 
     @Override
-    public CraftItemFactory getItemFactory() {
-        return CraftItemFactory.instance();
-    }
-
-    @Override
     public CraftScoreboardManager getScoreboardManager() {
         return scoreboardManager;
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index c03c239..4541a86 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -11,6 +11,7 @@ import java.util.Iterator;
 import java.util.Random;
 import java.util.Set;
 import java.util.UUID;
+import java.util.function.Predicate;
 
 import net.minecraft.server.*;
 
@@ -30,15 +31,20 @@ import org.bukkit.WorldBorder;
 import org.bukkit.block.Biome;
 import org.bukkit.block.Block;
 import org.bukkit.block.BlockFace;
+import org.bukkit.block.BlockImage;
+import org.bukkit.geometry.CoarseTransform;
+import org.bukkit.region.BlockRegion;
 import org.bukkit.block.BlockState;
+import org.bukkit.geometry.Transform;
+import org.bukkit.geometry.Vec3;
 import org.bukkit.craftbukkit.block.CraftBlock;
+import org.bukkit.craftbukkit.block.CraftBlockImage;
 import org.bukkit.craftbukkit.block.CraftBlockState;
 import org.bukkit.craftbukkit.entity.*;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.craftbukkit.metadata.BlockMetadataStore;
 import org.bukkit.craftbukkit.potion.CraftPotionUtil;
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
-import org.bukkit.craftbukkit.util.LongHash;
 import org.bukkit.entity.*;
 import org.bukkit.entity.Entity;
 import org.bukkit.entity.minecart.CommandMinecart;
@@ -100,6 +106,11 @@ public class CraftWorld implements World {
         return getChunkAt(x >> 4, z >> 4).getBlock(x & 0xF, y, z & 0xF);
     }
 
+    @Override
+    public Block getBlockAt(Vec3 position) {
+        return new CraftBlock((CraftChunk) getChunkAt(position), position);
+    }
+
     public int getBlockTypeIdAt(int x, int y, int z) {
         return CraftMagicNumbers.getId(world.getType(new BlockPosition(x, y, z)).getBlock());
     }
@@ -1546,4 +1557,48 @@ public class CraftWorld implements World {
             cps.unload(chunk);
         }
     }
+
+    @Override
+    public boolean hasMaterialAt(MaterialData material, Vec3 position) {
+        final IBlockData nms = CraftMagicNumbers.getBlockData(material);
+        return nms.equals(world.getType(BlockPosition.of(position)));
+    }
+
+    @Override
+    public boolean hasMaterialAt(Set<MaterialData> materials, Vec3 position) {
+        final Set<IBlockData> nms = CraftMagicNumbers.getBlockData(materials);
+        return nms.contains(world.getType(BlockPosition.of(position)));
+    }
+
+    @Override
+    public Predicate<Vec3> hasMaterialAt(MaterialData material) {
+        final IBlockData nms = CraftMagicNumbers.getBlockData(material);
+        return position -> nms.equals(world.getType(BlockPosition.of(position)));
+    }
+
+    @Override
+    public Predicate<Vec3> hasMaterialAt(Set<MaterialData> materials) {
+        final Set<IBlockData> nms = CraftMagicNumbers.getBlockData(materials);
+        return position -> nms.contains(world.getType(BlockPosition.of(position)));
+    }
+
+    @Override
+    public BlockImage copyBlocks(BlockRegion region, boolean includeAir, boolean clearSource) {
+        return new CraftBlockImage(this, region, includeAir, clearSource);
+    }
+
+    @Override
+    public int pasteBlocks(BlockImage image, CoarseTransform transform) {
+        return image.paste(this, transform);
+    }
+
+    @Override
+    public int pasteBlocks(BlockImage image, Vec3 offset) {
+        return pasteBlocks(image, CoarseTransform.translation(offset));
+    }
+
+    @Override
+    public int pasteBlocks(BlockImage image) {
+        return pasteBlocks(image, Transform.identity());
+    }
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
index bc7e949..2f70626 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
@@ -4,9 +4,24 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
-
-import net.minecraft.server.*;
-
+import java.util.Objects;
+
+import net.minecraft.server.BiomeBase;
+import net.minecraft.server.BlockCocoa;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.BlockRedstoneWire;
+import net.minecraft.server.BlockTileEntity;
+import net.minecraft.server.Blocks;
+import net.minecraft.server.EnumDirection;
+import net.minecraft.server.EnumSkyBlock;
+import net.minecraft.server.GameProfileSerializer;
+import net.minecraft.server.IBlockData;
+import net.minecraft.server.Item;
+import net.minecraft.server.MinecraftKey;
+import net.minecraft.server.MovingObjectPosition;
+import net.minecraft.server.NBTTagCompound;
+import net.minecraft.server.TileEntitySkull;
+import net.minecraft.server.Vec3D;
 import org.bukkit.Chunk;
 import org.bukkit.Location;
 import org.bukkit.Material;
@@ -25,18 +40,19 @@ import org.bukkit.metadata.MetadataValue;
 import org.bukkit.plugin.Plugin;
 import org.bukkit.util.BlockVector;
 import org.bukkit.util.RayBlockIntersection;
+import org.bukkit.geometry.Vec3;
 import org.bukkit.util.Vector;
 
 public class CraftBlock implements Block {
     private final CraftChunk chunk;
-    private final int x;
-    private final int y;
-    private final int z;
+    private final BlockPosition position;
 
     public CraftBlock(CraftChunk chunk, int x, int y, int z) {
-        this.x = x;
-        this.y = y;
-        this.z = z;
+        this(chunk, BlockPosition.of(x, y, z));
+    }
+
+    public CraftBlock(CraftChunk chunk, Vec3 position) {
+        this.position = BlockPosition.copyOf(position);
         this.chunk = chunk;
     }
 
@@ -52,16 +68,19 @@ public class CraftBlock implements Block {
         return chunk.getWorld();
     }
 
+    @Override
+    public BlockPosition getPosition() {
+        return position;
+    }
+
     public Location getLocation() {
-        return new Location(getWorld(), x, y, z);
+        return new Location(getWorld(), position);
     }
 
     public Location getLocation(Location loc) {
         if (loc != null) {
             loc.setWorld(getWorld());
-            loc.setX(x);
-            loc.setY(y);
-            loc.setZ(z);
+            loc.setPosition(position);
             loc.setYaw(0);
             loc.setPitch(0);
         }
@@ -70,19 +89,19 @@ public class CraftBlock implements Block {
     }
 
     public BlockVector getVector() {
-        return new BlockVector(x, y, z);
+        return new BlockVector(position);
     }
 
     public int getX() {
-        return x;
+        return position.coarseX();
     }
 
     public int getY() {
-        return y;
+        return position.coarseY();
     }
 
     public int getZ() {
-        return z;
+        return position.coarseZ();
     }
 
     public Chunk getChunk() {
@@ -103,17 +122,16 @@ public class CraftBlock implements Block {
 
     private void setData(final byte data, int flag) {
         net.minecraft.server.World world = chunk.getHandle().getWorld();
-        BlockPosition position = new BlockPosition(x, y, z);
         IBlockData blockData = world.getType(position);
         world.setTypeAndData(position, blockData.getBlock().fromLegacyData(data), flag);
     }
 
     private IBlockData getData0() {
-        return chunk.getHandle().getBlockData(new BlockPosition(x, y, z));
+        return chunk.getHandle().getBlockData(position);
     }
 
     public byte getData() {
-        IBlockData blockData = chunk.getHandle().getBlockData(new BlockPosition(x, y, z));
+        IBlockData blockData = chunk.getHandle().getBlockData(position);
         return (byte) blockData.getBlock().toLegacyData(blockData);
     }
 
@@ -137,7 +155,6 @@ public class CraftBlock implements Block {
 
     public boolean setTypeIdAndData(final int type, final byte data, final boolean applyPhysics) {
         IBlockData blockData = getNMSBlock(type).fromLegacyData(data);
-        BlockPosition position = new BlockPosition(x, y, z);
 
         // SPIGOT-611: need to do this to prevent glitchiness. Easier to handle this here (like /setblock) than to fix weirdness in tile entity cleanup
         if (type != 0 && blockData.getBlock() instanceof BlockTileEntity && type != getTypeId()) {
@@ -168,19 +185,19 @@ public class CraftBlock implements Block {
     @Deprecated
     @Override
     public int getTypeId() {
-        return CraftMagicNumbers.getId(chunk.getHandle().getBlockData(new BlockPosition(this.x, this.y, this.z)).getBlock());
+        return CraftMagicNumbers.getId(chunk.getHandle().getBlockData(position).getBlock());
     }
 
     public byte getLightLevel() {
-        return (byte) chunk.getHandle().getWorld().getLightLevel(new BlockPosition(this.x, this.y, this.z));
+        return (byte) chunk.getHandle().getWorld().getLightLevel(position);
     }
 
     public byte getLightFromSky() {
-        return (byte) chunk.getHandle().getBrightness(EnumSkyBlock.SKY, new BlockPosition(this.x, this.y, this.z));
+        return (byte) chunk.getHandle().getBrightness(EnumSkyBlock.SKY, position);
     }
 
     public byte getLightFromBlocks() {
-        return (byte) chunk.getHandle().getBrightness(EnumSkyBlock.BLOCK, new BlockPosition(this.x, this.y, this.z));
+        return (byte) chunk.getHandle().getBrightness(EnumSkyBlock.BLOCK, position);
     }
 
 
@@ -221,7 +238,7 @@ public class CraftBlock implements Block {
 
     @Override
     public String toString() {
-        return "CraftBlock{" + "chunk=" + chunk + ",x=" + x + ",y=" + y + ",z=" + z + ",type=" + getType() + ",data=" + getData() + '}';
+        return "CraftBlock{" + "chunk=" + chunk + ",position=" + position + ",type=" + getType() + ",data=" + getData() + '}';
     }
 
     public static BlockFace notchToBlockFace(EnumDirection notch) {
@@ -313,11 +330,11 @@ public class CraftBlock implements Block {
     }
 
     public Biome getBiome() {
-        return getWorld().getBiome(x, z);
+        return getWorld().getBiome(position);
     }
 
     public void setBiome(Biome bio) {
-        getWorld().setBiome(x, z, bio);
+        getWorld().setBiome(position, bio);
     }
 
     public static Biome biomeBaseToBiome(BiomeBase base) {
@@ -337,19 +354,19 @@ public class CraftBlock implements Block {
     }
 
     public double getTemperature() {
-        return getWorld().getTemperature(x, z);
+        return getWorld().getTemperature(position);
     }
 
     public double getHumidity() {
-        return getWorld().getHumidity(x, z);
+        return getWorld().getHumidity(position);
     }
 
     public boolean isBlockPowered() {
-        return chunk.getHandle().getWorld().getBlockPower(new BlockPosition(x, y, z)) > 0;
+        return chunk.getHandle().getWorld().getBlockPower(position) > 0;
     }
 
     public boolean isBlockIndirectlyPowered() {
-        return chunk.getHandle().getWorld().isBlockIndirectlyPowered(new BlockPosition(x, y, z));
+        return chunk.getHandle().getWorld().isBlockIndirectlyPowered(position);
     }
 
     @Override
@@ -358,20 +375,20 @@ public class CraftBlock implements Block {
         if (!(o instanceof CraftBlock)) return false;
         CraftBlock other = (CraftBlock) o;
 
-        return this.x == other.x && this.y == other.y && this.z == other.z && this.getWorld().equals(other.getWorld());
+        return this.getPosition().equals(other.getPosition()) && this.getWorld().equals(other.getWorld());
     }
 
     @Override
     public int hashCode() {
-        return this.y << 24 ^ this.x ^ this.z ^ this.getWorld().hashCode();
+        return Objects.hash(getPosition(), getWorld());
     }
 
     public boolean isBlockFacePowered(BlockFace face) {
-        return chunk.getHandle().getWorld().isBlockFacePowered(new BlockPosition(x, y, z), blockFaceToNotch(face));
+        return chunk.getHandle().getWorld().isBlockFacePowered(position, blockFaceToNotch(face));
     }
 
     public boolean isBlockFaceIndirectlyPowered(BlockFace face) {
-        int power = chunk.getHandle().getWorld().getBlockFacePower(new BlockPosition(x, y, z), blockFaceToNotch(face));
+        int power = chunk.getHandle().getWorld().getBlockFacePower(position, blockFaceToNotch(face));
 
         Block relative = getRelative(face);
         if (relative.getType() == Material.REDSTONE_WIRE) {
@@ -385,12 +402,12 @@ public class CraftBlock implements Block {
         int power = 0;
         BlockRedstoneWire wire = Blocks.REDSTONE_WIRE;
         net.minecraft.server.World world = chunk.getHandle().getWorld();
-        if ((face == BlockFace.DOWN || face == BlockFace.SELF) && world.isBlockFacePowered(new BlockPosition(x, y - 1, z), EnumDirection.DOWN)) power = wire.getPower(world, new BlockPosition(x, y - 1, z), power);
-        if ((face == BlockFace.UP || face == BlockFace.SELF) && world.isBlockFacePowered(new BlockPosition(x, y + 1, z), EnumDirection.UP)) power = wire.getPower(world, new BlockPosition(x, y + 1, z), power);
-        if ((face == BlockFace.EAST || face == BlockFace.SELF) && world.isBlockFacePowered(new BlockPosition(x + 1, y, z), EnumDirection.EAST)) power = wire.getPower(world, new BlockPosition(x + 1, y, z), power);
-        if ((face == BlockFace.WEST || face == BlockFace.SELF) && world.isBlockFacePowered(new BlockPosition(x - 1, y, z), EnumDirection.WEST)) power = wire.getPower(world, new BlockPosition(x - 1, y, z), power);
-        if ((face == BlockFace.NORTH || face == BlockFace.SELF) && world.isBlockFacePowered(new BlockPosition(x, y, z - 1), EnumDirection.NORTH)) power = wire.getPower(world, new BlockPosition(x, y, z - 1), power);
-        if ((face == BlockFace.SOUTH || face == BlockFace.SELF) && world.isBlockFacePowered(new BlockPosition(x, y, z + 1), EnumDirection.SOUTH)) power = wire.getPower(world, new BlockPosition(x, y, z - 1), power);
+        if ((face == BlockFace.DOWN || face == BlockFace.SELF) && world.isBlockFacePowered(position.down(), EnumDirection.DOWN)) power = wire.getPower(world, position.down(), power);
+        if ((face == BlockFace.UP || face == BlockFace.SELF) && world.isBlockFacePowered(position.up(), EnumDirection.UP)) power = wire.getPower(world, position.up(), power);
+        if ((face == BlockFace.EAST || face == BlockFace.SELF) && world.isBlockFacePowered(position.east(), EnumDirection.EAST)) power = wire.getPower(world, position.east(), power);
+        if ((face == BlockFace.WEST || face == BlockFace.SELF) && world.isBlockFacePowered(position.west(), EnumDirection.WEST)) power = wire.getPower(world, position.west(), power);
+        if ((face == BlockFace.NORTH || face == BlockFace.SELF) && world.isBlockFacePowered(position.north(), EnumDirection.NORTH)) power = wire.getPower(world, position.north(), power);
+        if ((face == BlockFace.SOUTH || face == BlockFace.SELF) && world.isBlockFacePowered(position.south(), EnumDirection.SOUTH)) power = wire.getPower(world, position.south(), power);
         return power > 0 ? power : (face == BlockFace.SELF ? isBlockIndirectlyPowered() : isBlockFaceIndirectlyPowered(face)) ? 15 : 0;
     }
 
@@ -423,7 +440,7 @@ public class CraftBlock implements Block {
         boolean result = false;
 
         if (block != null && block != Blocks.AIR) {
-            block.dropNaturally(chunk.getHandle().getWorld(), new BlockPosition(x, y, z), block.fromLegacyData(data), 1.0F, 0);
+            block.dropNaturally(chunk.getHandle().getWorld(), position, block.fromLegacyData(data), 1.0F, 0);
             result = true;
         }
 
@@ -453,7 +470,7 @@ public class CraftBlock implements Block {
                     // Skulls are special, their data is based on the tile entity
                     if (Blocks.SKULL == block) {
                         net.minecraft.server.ItemStack nmsStack = new net.minecraft.server.ItemStack(item, 1, block.getDropData(data));
-                        TileEntitySkull tileentityskull = (TileEntitySkull) chunk.getHandle().getWorld().getTileEntity(new BlockPosition(x, y, z));
+                        TileEntitySkull tileentityskull = (TileEntitySkull) chunk.getHandle().getWorld().getTileEntity(position);
 
                         if (tileentityskull.getSkullType() == 3 && tileentityskull.getGameProfile() != null) {
                             nmsStack.setTag(new NBTTagCompound());
@@ -516,7 +533,7 @@ public class CraftBlock implements Block {
 
         MovingObjectPosition hit = nms.a(getData0(),
                                          chunk.getCraftWorld().getHandle(),
-                                         new BlockPosition(x, y, z),
+                                         position,
                                          new Vec3D(start.getX(), start.getY(), start.getZ()),
                                          new Vec3D(end.getX(), end.getY(), end.getZ()));
 
@@ -543,7 +560,7 @@ public class CraftBlock implements Block {
     }
 
     public BlockPosition nmsPosition() {
-        return new BlockPosition(x, y, z);
+        return position;
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockFactory.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockFactory.java
new file mode 100644
index 0000000..de61fef
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockFactory.java
@@ -0,0 +1,91 @@
+package org.bukkit.craftbukkit.block;
+
+import net.minecraft.server.EnumBlockMirror;
+import net.minecraft.server.EnumBlockRotation;
+import net.minecraft.server.IBlockData;
+import org.bukkit.block.BlockFactory;
+import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.bukkit.geometry.BlockRotoflection;
+import org.bukkit.geometry.BlockReflection;
+import org.bukkit.geometry.BlockRotation;
+import org.bukkit.geometry.CoarseTransform;
+import org.bukkit.material.MaterialData;
+
+public class CraftBlockFactory implements BlockFactory {
+
+    private static final CraftBlockFactory INSTANCE = new CraftBlockFactory();
+    public static CraftBlockFactory instance() { return INSTANCE; }
+
+    public static BlockReflection toBukkit(EnumBlockMirror nms) {
+        switch(nms) {
+            case NONE: return BlockReflection.NONE;
+            case LEFT_RIGHT: return BlockReflection.LEFT_RIGHT;
+            case FRONT_BACK: return BlockReflection.FRONT_BACK;
+        }
+        throw new IllegalStateException();
+    }
+
+    public static EnumBlockMirror toNms(BlockReflection bukkit) {
+        switch(bukkit) {
+            case NONE: return EnumBlockMirror.NONE;
+            case LEFT_RIGHT: return EnumBlockMirror.LEFT_RIGHT;
+            case FRONT_BACK: return EnumBlockMirror.FRONT_BACK;
+        }
+        throw new IllegalStateException();
+    }
+
+    public static BlockRotation toBukkit(EnumBlockRotation nms) {
+        switch(nms) {
+            case NONE: return BlockRotation.NONE;
+            case CLOCKWISE_90: return BlockRotation.CLOCKWISE_90;
+            case CLOCKWISE_180: return BlockRotation.CLOCKWISE_180;
+            case COUNTERCLOCKWISE_90: return BlockRotation.COUNTERCLOCKWISE_90;
+        }
+        throw new IllegalStateException();
+    }
+
+    public static EnumBlockRotation toNms(BlockRotation nms) {
+        switch(nms) {
+            case NONE: return EnumBlockRotation.NONE;
+            case CLOCKWISE_90: return EnumBlockRotation.CLOCKWISE_90;
+            case CLOCKWISE_180: return EnumBlockRotation.CLOCKWISE_180;
+            case COUNTERCLOCKWISE_90: return EnumBlockRotation.COUNTERCLOCKWISE_90;
+        }
+        throw new IllegalStateException();
+    }
+
+    public IBlockData transform(IBlockData data, BlockRotoflection transform) {
+        if(transform.isIdentity()) return data;
+
+        // Mojang applies reflection first, so we do too
+        data = data.a(toNms(transform.reflection()));
+        data = data.a(toNms(transform.rotation()));
+        return data;
+    }
+
+    @Override
+    public MaterialData transform(MaterialData material, BlockRotoflection transform) {
+        if(transform.isIdentity()) return material;
+
+        return CraftMagicNumbers.nmsBlockStateToMaterialData(
+            transform(CraftMagicNumbers.getBlockData(material), transform)
+        );
+    }
+
+    @Override
+    public MaterialData transform(MaterialData material, CoarseTransform transform) {
+        return transform(material, transform.orientation());
+    }
+
+    @Override
+    public MaterialData reflect(MaterialData material, BlockReflection reflection) {
+        if(reflection == BlockReflection.NONE) return material;
+        return transform(material, BlockRotoflection.of(reflection));
+    }
+
+    @Override
+    public MaterialData rotate(MaterialData material, BlockRotation rotation) {
+        if(rotation == BlockRotation.NONE) return material;
+        return transform(material, BlockRotoflection.of(rotation));
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockImage.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockImage.java
new file mode 100644
index 0000000..6bd8ba3
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockImage.java
@@ -0,0 +1,232 @@
+package org.bukkit.craftbukkit.block;
+
+import java.util.List;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Iterables;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.Blocks;
+import net.minecraft.server.IBlockData;
+import net.minecraft.server.IInventory;
+import net.minecraft.server.NBTTagCompound;
+import net.minecraft.server.NextTickListEntry;
+import net.minecraft.server.StructureBoundingBox;
+import net.minecraft.server.TileEntity;
+import org.bukkit.Bukkit;
+import org.bukkit.World;
+import org.bukkit.block.BlockImage;
+import org.bukkit.geometry.BlockRotoflection;
+import org.bukkit.geometry.CoarseTransform;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.bukkit.material.MaterialData;
+import org.bukkit.region.BlockRegion;
+import org.bukkit.geometry.Vec3;
+
+/**
+ * Read/write algorithms are derived from the code for the /clone command,
+ * which can be found in {@link net.minecraft.server.CommandClone}.
+ */
+public class CraftBlockImage implements BlockImage {
+
+    static class BlockRecord extends BlockPosition {
+        final IBlockData blockData;
+        final NBTTagCompound tileEntityData;
+        NextTickListEntry tickListEntry;
+
+        BlockRecord(Vec3 pos, IBlockData blockData, NBTTagCompound tileEntityData) {
+            super(pos.coarseX(), pos.coarseY(), pos.coarseZ());
+            this.blockData = blockData;
+            this.tileEntityData = tileEntityData;
+        }
+
+        void pasteTileEntity(net.minecraft.server.World world, BlockPosition pos) {
+            final TileEntity tileEntity = world.getTileEntity(pos);
+
+            if(tileEntityData != null && tileEntity != null) {
+                tileEntityData.setInt("x", pos.getX());
+                tileEntityData.setInt("y", pos.getY());
+                tileEntityData.setInt("z", pos.getZ());
+
+                tileEntity.a(tileEntityData);
+                tileEntity.update();
+            }
+        }
+
+        void pasteTick(net.minecraft.server.World world, BlockPosition pos, long tickTime) {
+            if(tickListEntry != null) {
+                world.b(pos, tickListEntry.a(), (int) (tickListEntry.b - tickTime), tickListEntry.c);
+            }
+        }
+    }
+
+    private final ImmutableMap<Vec3, BlockRecord> byPosition;
+    private final ImmutableList<BlockRecord> earlyBlocks;
+    private final ImmutableList<BlockRecord> tileEntities;
+    private final ImmutableList<BlockRecord> lateBlocks;
+    private final ImmutableList<BlockRecord> tickedBlocks;
+    private final long tickTime;
+
+    @Override
+    public BlockRegion region() {
+        return BlockRegion.of(byPosition.keySet());
+    }
+
+    @Override
+    public MaterialData materialAt(Vec3 pos) {
+        final BlockRecord r = byPosition.get(pos.coarseCopy());
+        return r == null ? null : CraftMagicNumbers.nmsBlockStateToMaterialData(r.blockData);
+    }
+
+    @Override
+    public boolean pasteBlock(Vec3 from, World world, Vec3 to, BlockRotoflection orientation) {
+        final BlockRecord record = byPosition.get(from.coarseCopy());
+        if(record == null) return false;
+
+        final CraftBlockFactory orienter = (CraftBlockFactory) Bukkit.blocks();
+        final net.minecraft.server.World nmsWorld = ((CraftWorld) world).getHandle();
+        final BlockPosition pos = BlockPosition.copyOf(to);
+        record.pasteTileEntity(nmsWorld, pos);
+        nmsWorld.setTypeAndData(pos, orienter.transform(record.blockData, orientation), 2);
+        record.pasteTick(nmsWorld, pos, tickTime);
+        return true;
+    }
+
+    public CraftBlockImage(CraftWorld craftWorld, BlockRegion region, boolean includeAir, boolean clearSource) {
+        final net.minecraft.server.WorldServer world = craftWorld.getHandle();
+        final BlockPosition.MutableBlockPosition mutablePosition = new BlockPosition.MutableBlockPosition();
+
+        final ImmutableMap.Builder<Vec3, BlockRecord> byPosition = ImmutableMap.builder();
+        final ImmutableList.Builder<BlockRecord> earlyBlocks = ImmutableList.builder();
+        final ImmutableList.Builder<BlockRecord> tileEntities = ImmutableList.builder();
+        final ImmutableList.Builder<BlockRecord> lateBlocks = ImmutableList.builder();
+
+        for(Vec3 position : region.mutableIterable()) {
+            // Avoid creating any objects for air blocks, as long as the region
+            // iterator is spitting out NMS BlockPositions.
+            mutablePosition.set(position);
+            final IBlockData blockData = world.getType(mutablePosition);
+
+            if(includeAir || blockData.getBlock() != Blocks.AIR) {
+                final BlockRecord block;
+
+                TileEntity tileEntity = world.getTileEntity(mutablePosition);
+                if(tileEntity != null) {
+                    block = new BlockRecord(mutablePosition, blockData, new NBTTagCompound());
+                    tileEntity.save(block.tileEntityData);
+                    tileEntities.add(block);
+
+                    if(clearSource && tileEntity instanceof IInventory) {
+                        ((IInventory) tileEntity).l(); // Clear inventory
+                    }
+                } else {
+                    block = new BlockRecord(mutablePosition, blockData, null);
+                    if (!block.blockData.b() && // flammable
+                        !block.blockData.h()) { // full-sized
+                        lateBlocks.add(block);
+                    } else {
+                        earlyBlocks.add(block);
+                    }
+                }
+
+                byPosition.put(block, block);
+            }
+        }
+
+        this.byPosition = byPosition.build();
+        this.earlyBlocks = earlyBlocks.build();
+        this.lateBlocks = lateBlocks.build();
+        this.tileEntities = tileEntities.build();
+
+        if(clearSource) {
+            final Iterable<BlockRecord> clearPositions = Iterables.concat(this.lateBlocks, this.tileEntities, this.earlyBlocks);
+
+            for(BlockRecord block : clearPositions) {
+                if(block.tileEntityData != null) {
+                    final TileEntity tileEntity = world.getTileEntity(block);
+                    if(tileEntity instanceof IInventory) {
+                        ((IInventory) tileEntity).l();
+                    }
+                }
+                world.setTypeAndData(block, Blocks.BARRIER.getBlockData(), 2);
+            }
+
+            for(BlockRecord block : clearPositions) {
+                world.setTypeAndData(block, Blocks.AIR.getBlockData(), 3);
+            }
+        }
+
+        this.tickTime = world.getWorldData().getTime();
+
+        final ImmutableList.Builder<BlockRecord> tickedBlocks = ImmutableList.builder();
+        final List<NextTickListEntry> ticks = world.a(new StructureBoundingBox(Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE), false);
+        if(ticks != null) {
+            for(NextTickListEntry tick : ticks) {
+                final BlockRecord block = this.byPosition.get(tick.a);
+                if(block != null) {
+                    block.tickListEntry = tick;
+                    tickedBlocks.add(block);
+                }
+            }
+        }
+        this.tickedBlocks = tickedBlocks.build();
+    }
+
+    @Override
+    public int paste(World world, CoarseTransform transform) {
+        final net.minecraft.server.WorldServer nmsWorld = ((CraftWorld) world).getHandle();
+
+        final Iterable<BlockRecord> allBlocks = Iterables.concat(earlyBlocks, tileEntities, lateBlocks);
+        final Iterable<BlockRecord> reversedBlocks = Iterables.concat(lateBlocks, tileEntities, earlyBlocks);
+
+        final BlockPosition.MutableBlockPosition mutablePosition = new BlockPosition.MutableBlockPosition();
+
+        // Fill the entire destination region with barrier blocks
+        for(BlockRecord block : reversedBlocks) {
+            mutablePosition.set(block);
+            transform.applyInPlace(mutablePosition);
+
+            // Clear any containers so they don't spill their contents
+            final TileEntity tileEntity = nmsWorld.getTileEntity(mutablePosition);
+            if (tileEntity instanceof IInventory) {
+                ((IInventory) tileEntity).l(); // Clear inventory
+            }
+
+            nmsWorld.setTypeAndData(mutablePosition, Blocks.BARRIER.getBlockData(), 2);
+        }
+
+        int affectedBlocks = 0;
+        final CraftBlockFactory orienter = (CraftBlockFactory) Bukkit.blocks();
+        final BlockRotoflection orientation = transform.orientation();
+
+        for(BlockRecord block : allBlocks) {
+            mutablePosition.set(block);
+            transform.applyInPlace(mutablePosition);
+            if(nmsWorld.setTypeAndData(mutablePosition, orienter.transform(block.blockData, orientation), 2)) {
+                ++affectedBlocks;
+            }
+        }
+
+        for(BlockRecord block : tileEntities) {
+            mutablePosition.set(block);
+            transform.applyInPlace(mutablePosition);
+            block.pasteTileEntity(nmsWorld, mutablePosition);
+            nmsWorld.setTypeAndData(mutablePosition, orienter.transform(block.blockData, orientation), 2);
+        }
+
+        for(BlockRecord block : reversedBlocks) {
+            mutablePosition.set(block);
+            transform.applyInPlace(mutablePosition);
+            nmsWorld.update(mutablePosition, block.blockData.getBlock());
+        }
+
+        for(BlockRecord block : tickedBlocks) {
+            mutablePosition.set(block.tickListEntry.a);
+            transform.applyInPlace(mutablePosition);
+            block.pasteTick(nmsWorld, mutablePosition, tickTime);
+        }
+
+        return affectedBlocks;
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
index 97b75b7..f6ef834 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
@@ -1,13 +1,22 @@
 package org.bukkit.craftbukkit.block;
 
+import java.util.List;
+import java.util.Objects;
+
 import net.minecraft.server.BlockPosition;
-import org.bukkit.Location;
-import org.bukkit.block.Block;
-import org.bukkit.block.BlockFace;
+import net.minecraft.server.IBlockData;
+import net.minecraft.server.TileEntity;
+import org.bukkit.Bukkit;
 import org.bukkit.Chunk;
+import org.bukkit.Location;
 import org.bukkit.Material;
 import org.bukkit.World;
+import org.bukkit.block.Block;
+import org.bukkit.geometry.BlockRotoflection;
+import org.bukkit.geometry.BlockReflection;
+import org.bukkit.geometry.BlockRotation;
 import org.bukkit.block.BlockState;
+import org.bukkit.geometry.CoarseTransform;
 import org.bukkit.craftbukkit.CraftChunk;
 import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
@@ -15,27 +24,19 @@ import org.bukkit.material.Attachable;
 import org.bukkit.material.MaterialData;
 import org.bukkit.metadata.MetadataValue;
 import org.bukkit.plugin.Plugin;
-
-import java.util.List;
-import net.minecraft.server.EnumDirection;
-import net.minecraft.server.IBlockData;
-import net.minecraft.server.TileEntity;
+import org.bukkit.geometry.Vec3;
 
 public class CraftBlockState implements BlockState {
     private final CraftWorld world;
+    private final BlockPosition position;
     private final CraftChunk chunk;
-    private final int x;
-    private final int y;
-    private final int z;
     protected int type;
     protected MaterialData data;
     protected int flag;
 
     public CraftBlockState(final Block block) {
         this.world = (CraftWorld) block.getWorld();
-        this.x = block.getX();
-        this.y = block.getY();
-        this.z = block.getZ();
+        this.position = BlockPosition.copyOf(block.getPosition());
         this.type = block.getTypeId();
         this.chunk = (CraftChunk) block.getChunk();
         this.flag = 3;
@@ -50,9 +51,9 @@ public class CraftBlockState implements BlockState {
 
     public CraftBlockState(Material material) {
         world = null;
+        position = null;
         type = material.getId();
         chunk = null;
-        x = y = z = 0;
     }
 
     public static CraftBlockState getBlockState(net.minecraft.server.World world, int x, int y, int z) {
@@ -68,16 +69,34 @@ public class CraftBlockState implements BlockState {
         return world;
     }
 
+    @Override
+    public World tryWorld() {
+        return world;
+    }
+
+    @Override
+    public BlockPosition getPosition() {
+        if(position == null) {
+            throw new IllegalStateException("This BlockState has no position");
+        }
+        return position;
+    }
+
+    @Override
+    public Vec3 tryPosition() {
+        return position;
+    }
+
     public int getX() {
-        return x;
+        return getPosition().coarseX();
     }
 
     public int getY() {
-        return y;
+        return getPosition().coarseY();
     }
 
     public int getZ() {
-        return z;
+        return getPosition().coarseZ();
     }
 
     public Chunk getChunk() {
@@ -151,8 +170,7 @@ public class CraftBlockState implements BlockState {
     }
 
     public Block getBlock() {
-        requirePlaced();
-        return world.getBlockAt(x, y, z);
+        return getWorld().getBlockAt(getPosition());
     }
 
     public boolean update() {
@@ -173,7 +191,7 @@ public class CraftBlockState implements BlockState {
             }
         }
 
-        BlockPosition pos = new BlockPosition(x, y, z);
+        BlockPosition pos = getPosition();
         IBlockData newBlock = CraftMagicNumbers.getBlock(getType()).fromLegacyData(getRawData());
         block.setTypeIdAndData(getTypeId(), getRawData(), applyPhysics);
         world.getHandle().notify(
@@ -205,15 +223,13 @@ public class CraftBlockState implements BlockState {
     }
 
     public Location getLocation() {
-        return new Location(world, x, y, z);
+        return new Location(getWorld(), getPosition());
     }
 
     public Location getLocation(Location loc) {
         if (loc != null) {
-            loc.setWorld(world);
-            loc.setX(x);
-            loc.setY(y);
-            loc.setZ(z);
+            loc.setWorld(getWorld());
+            loc.setPosition(getPosition());
             loc.setYaw(0);
             loc.setPitch(0);
         }
@@ -227,41 +243,20 @@ public class CraftBlockState implements BlockState {
 
     @Override
     public boolean equals(Object obj) {
-        if (obj == null) {
-            return false;
-        }
-        if (getClass() != obj.getClass()) {
-            return false;
-        }
-        final CraftBlockState other = (CraftBlockState) obj;
-        if (this.world != other.world && (this.world == null || !this.world.equals(other.world))) {
-            return false;
-        }
-        if (this.x != other.x) {
-            return false;
-        }
-        if (this.y != other.y) {
-            return false;
-        }
-        if (this.z != other.z) {
-            return false;
-        }
-        if (this.type != other.type) {
-            return false;
-        }
-        if (this.data != other.data && (this.data == null || !this.data.equals(other.data))) {
-            return false;
-        }
-        return true;
+        if(this == obj) return true;
+        if(!(obj instanceof BlockState)) return false;
+        final BlockState that = (BlockState) obj;
+        return Objects.equals(this.world, that.tryWorld()) &&
+               Objects.equals(this.position, that.tryPosition()) &&
+               this.type == that.getTypeId() &&
+               Objects.equals(this.data, that.getMaterialData());
     }
 
     @Override
     public int hashCode() {
         int hash = 7;
         hash = 73 * hash + (this.world != null ? this.world.hashCode() : 0);
-        hash = 73 * hash + this.x;
-        hash = 73 * hash + this.y;
-        hash = 73 * hash + this.z;
+        hash = 73 * hash + (this.position != null ? this.position.hashCode() : 0);
         hash = 73 * hash + this.type;
         hash = 73 * hash + (this.data != null ? this.data.hashCode() : 0);
         return hash;
@@ -298,6 +293,11 @@ public class CraftBlockState implements BlockState {
     }
 
     @Override
+    public boolean hasPosition() {
+        return position != null;
+    }
+
+    @Override
     public boolean isPlaced() {
         return world != null;
     }
@@ -307,4 +307,24 @@ public class CraftBlockState implements BlockState {
             throw new IllegalStateException("The blockState must be placed to call this method");
         }
     }
+
+    @Override
+    public void reflect(BlockReflection reflection) {
+        setMaterialData(Bukkit.blocks().reflect(getMaterialData(), reflection));
+    }
+
+    @Override
+    public void rotate(BlockRotation rotation) {
+        setMaterialData(Bukkit.blocks().rotate(getMaterialData(), rotation));
+    }
+
+    @Override
+    public void reorient(BlockRotoflection orientation) {
+        setMaterialData(Bukkit.blocks().transform(getMaterialData(), orientation));
+    }
+
+    @Override
+    public void reorient(CoarseTransform transform) {
+        setMaterialData(Bukkit.blocks().transform(getMaterialData(), transform));
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index 2fda490..cdefe12 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -34,7 +34,7 @@ import org.bukkit.permissions.PermissionAttachment;
 import org.bukkit.permissions.PermissionAttachmentInfo;
 import org.bukkit.permissions.ServerOperator;
 import org.bukkit.plugin.Plugin;
-import org.bukkit.util.Cuboid;
+import org.bukkit.geometry.Cuboid;
 import org.bukkit.util.ImVector;
 import org.bukkit.util.Vector;
 
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftLivingEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftLivingEntity.java
index cab841c..593ea16 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftLivingEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftLivingEntity.java
@@ -75,7 +75,7 @@ import org.bukkit.potion.PotionEffectType;
 import org.bukkit.potion.PotionType;
 import org.bukkit.util.BlockIterator;
 import org.bukkit.util.NumberConversions;
-import org.bukkit.util.Ray;
+import org.bukkit.geometry.Ray;
 import org.bukkit.util.Vector;
 
 public class CraftLivingEntity extends CraftEntity implements LivingEntity {
diff --git a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
index b3ecbb7..a104746 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
@@ -1,5 +1,6 @@
 package org.bukkit.craftbukkit.util;
 
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
 import java.util.ArrayList;
 import java.util.Iterator;
@@ -101,6 +102,23 @@ public final class CraftMagicNumbers implements UnsafeValues {
         return getBlock(material.getItemType()).fromLegacyData(material.getData());
     }
 
+    public static Set<IBlockData> getBlockData(Set<MaterialData> materials) {
+        ImmutableSet.Builder<IBlockData> nms = ImmutableSet.builder();
+        for(MaterialData bukkit : materials) {
+            nms.add(getBlockData(bukkit));
+        }
+        return nms.build();
+    }
+
+    public static MaterialData nmsBlockStateToMaterialData(IBlockData data) {
+        final Block block = data.getBlock();
+        final int legacyId = getId(block);
+        final byte legacyData = (byte) block.toLegacyData(data);
+        final Material material = Material.getMaterial(legacyId);
+        return material == null ? new MaterialData(legacyId, legacyData)
+                                : material.getNewData(legacyData);
+    }
+
     @Override
     public Material getMaterialFromInternalName(String name) {
         return getMaterial((Item) Item.REGISTRY.get(new MinecraftKey(name)));
diff --git a/src/main/java/org/bukkit/craftbukkit/util/CraftVectorFactory.java b/src/main/java/org/bukkit/craftbukkit/util/CraftVectorFactory.java
new file mode 100644
index 0000000..287c095
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/util/CraftVectorFactory.java
@@ -0,0 +1,49 @@
+package org.bukkit.craftbukkit.util;
+
+import net.minecraft.server.BlockPosition;
+import org.bukkit.util.ImVector;
+import org.bukkit.geometry.MutableVec3;
+import org.bukkit.util.NumberConversions;
+import org.bukkit.geometry.Vec3;
+import org.bukkit.util.Vector;
+import org.bukkit.geometry.VectorFactory;
+
+public class CraftVectorFactory implements VectorFactory {
+
+    @Override
+    public Vec3 coarse(int x, int y, int z) {
+        return BlockPosition.of(x, y, z);
+    }
+
+    @Override
+    public Vec3 coarse(double x, double y, double z) {
+        return BlockPosition.of(NumberConversions.floor(x),
+                                NumberConversions.floor(y),
+                                NumberConversions.floor(z));
+    }
+
+    @Override
+    public Vec3 fine(int x, int y, int z) {
+        return ImVector.of(x, y, z);
+    }
+
+    @Override
+    public Vec3 fine(double x, double y, double z) {
+        return ImVector.of(x, y, z);
+    }
+
+    @Override
+    public Vec3 coarseZero() {
+        return BlockPosition.ZERO;
+    }
+
+    @Override
+    public MutableVec3 coarseMutable(int x, int y, int z) {
+        return new BlockPosition.MutableBlockPosition(x, y, z);
+    }
+
+    @Override
+    public MutableVec3 fineMutable(double x, double y, double z) {
+        return new Vector(x, y, z);
+    }
+}
diff --git a/src/test/java/org/bukkit/block/BlockFaceTest.java b/src/test/java/org/bukkit/block/BlockFaceTest.java
new file mode 100644
index 0000000..023f7db
--- /dev/null
+++ b/src/test/java/org/bukkit/block/BlockFaceTest.java
@@ -0,0 +1,59 @@
+package org.bukkit.block;
+
+import org.bukkit.support.BukkitRuntimeTest;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+public class BlockFaceTest extends BukkitRuntimeTest {
+
+    @Test
+    public void lookupByYaw() throws Exception {
+        assertEquals(BlockFace.SOUTH, BlockFace.byBlockYaw(0));
+        assertEquals(BlockFace.WEST, BlockFace.byBlockYaw(4));
+        assertEquals(BlockFace.NORTH, BlockFace.byBlockYaw(8));
+        assertEquals(BlockFace.EAST, BlockFace.byBlockYaw(12));
+
+        for(int i = 0; i < 16; i++) {
+            final BlockFace face = BlockFace.byBlockYaw(i);
+            assertEquals(i, face.blockYaw());
+        }
+    }
+
+    @Test
+    public void lookupByDirection() throws Exception {
+        // vertical
+        assertEquals(BlockFace.SELF, BlockFace.byDirection(0, 0, 0));
+        assertEquals(BlockFace.DOWN, BlockFace.byDirection(0, -1, 0));
+        assertEquals(BlockFace.UP, BlockFace.byDirection(0, 1, 0));
+
+        // cardinals
+        assertEquals(BlockFace.WEST, BlockFace.byDirection(-1, 0, 0));
+        assertEquals(BlockFace.EAST, BlockFace.byDirection(1, 0, 0));
+        assertEquals(BlockFace.NORTH, BlockFace.byDirection(0, 0, -1));
+        assertEquals(BlockFace.SOUTH, BlockFace.byDirection(0, 0, 1));
+
+        // diagonals
+        assertEquals(BlockFace.NORTH_WEST, BlockFace.byDirection(-1, 0, -1));
+        assertEquals(BlockFace.NORTH_EAST, BlockFace.byDirection(1, 0, -1));
+        assertEquals(BlockFace.SOUTH_WEST, BlockFace.byDirection(-1, 0, 1));
+        assertEquals(BlockFace.SOUTH_EAST, BlockFace.byDirection(1, 0, 1));
+
+        // Z major
+        assertEquals(BlockFace.NORTH_NORTH_WEST, BlockFace.byDirection(-1, 0, -2));
+        assertEquals(BlockFace.NORTH_NORTH_EAST, BlockFace.byDirection(1, 0, -2));
+        assertEquals(BlockFace.SOUTH_SOUTH_WEST, BlockFace.byDirection(-1, 0, 2));
+        assertEquals(BlockFace.SOUTH_SOUTH_EAST, BlockFace.byDirection(1, 0, 2));
+
+        // X major
+        assertEquals(BlockFace.WEST_NORTH_WEST, BlockFace.byDirection(-2, 0, -1));
+        assertEquals(BlockFace.EAST_NORTH_EAST, BlockFace.byDirection(2, 0, -1));
+        assertEquals(BlockFace.WEST_SOUTH_WEST, BlockFace.byDirection(-2, 0, 1));
+        assertEquals(BlockFace.EAST_SOUTH_EAST, BlockFace.byDirection(2, 0, 1));
+
+        for(BlockFace face : BlockFace.values()) {
+            assertTrue(face.coarseEquals(face.normal()));
+            assertEquals(face, BlockFace.byDirection(face.normal()));
+        }
+    }
+}
diff --git a/src/test/java/org/bukkit/block/BlockFactoryTest.java b/src/test/java/org/bukkit/block/BlockFactoryTest.java
new file mode 100644
index 0000000..0502300
--- /dev/null
+++ b/src/test/java/org/bukkit/block/BlockFactoryTest.java
@@ -0,0 +1,58 @@
+package org.bukkit.block;
+
+import org.bukkit.Bukkit;
+import org.bukkit.Material;
+import org.bukkit.geometry.BlockRotoflection;
+import org.bukkit.geometry.BlockReflection;
+import org.bukkit.geometry.BlockRotation;
+import org.bukkit.material.Directional;
+import org.bukkit.material.Lever;
+import org.bukkit.material.MaterialData;
+import org.bukkit.support.BukkitRuntimeTest;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+public class BlockFactoryTest extends BukkitRuntimeTest {
+
+    void normalize(MaterialData data) {
+        final Directional directional = (Directional) data;
+        directional.setFacingDirection(directional.getFacing());
+    }
+
+    void test(MaterialData material, BlockRotoflection rotoflection) {
+        normalize(material);
+
+        // Transform with the BlockOrienter
+        final MaterialData actual = Bukkit.blocks().transform(material, rotoflection);
+
+        // Transform through the Directional interface
+        final MaterialData expected = material.clone();
+        if(expected instanceof Lever) {
+            final Lever lever = (Lever) expected;
+            lever.setFacingDirection(rotoflection.transform().apply(lever.getFacing()),
+                                     rotoflection.apply(lever.getAxis()));
+        } else {
+            final Directional directional = (Directional) expected;
+            final BlockFace facing = directional.getFacing();
+            directional.setFacingDirection(rotoflection.transform().apply(facing));
+        }
+
+        // Assert identical results
+        assertEquals("material=" + material.getItemType() + " data=" + material + " rotoflection=" + rotoflection,
+                     expected, actual);
+    }
+
+    @Test
+    public void reorientDirectionalBlocks() throws Exception {
+        for(Material type : Material.values()) {
+            if(Directional.class.isAssignableFrom(type.getData())) {
+                final MaterialData material = type.getNewData((byte) 0);
+                for(BlockRotation rotation : BlockRotation.values()) {
+                    test(material, BlockRotoflection.of(BlockReflection.NONE, rotation));
+                    test(material, BlockRotoflection.of(BlockReflection.X, rotation));
+                }
+            }
+        }
+    }
+}
diff --git a/src/test/java/org/bukkit/block/BlockReflectionTest.java b/src/test/java/org/bukkit/block/BlockReflectionTest.java
new file mode 100644
index 0000000..12ccd1a
--- /dev/null
+++ b/src/test/java/org/bukkit/block/BlockReflectionTest.java
@@ -0,0 +1,30 @@
+package org.bukkit.block;
+
+import org.bukkit.geometry.BlockReflection;
+import org.bukkit.support.BukkitRuntimeTest;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+public class BlockReflectionTest extends BukkitRuntimeTest {
+
+    static String swap(String in, String a, String b) {
+        return in.replace(a, "*")
+                 .replace(b, a)
+                 .replace("*", b);
+    }
+
+    void applyToFace(BlockReflection reflection, String here, String there) {
+        for(BlockFace face : BlockFace.values()) {
+            BlockFace expected = BlockFace.valueOf(swap(face.name(), here, there));
+            BlockFace actual = reflection.transform().apply(face);
+            assertEquals(expected, actual);
+        }
+    }
+
+    @Test
+    public void applyToFace() throws Exception {
+        applyToFace(BlockReflection.NORTH_SOUTH, "NORTH", "SOUTH");
+        applyToFace(BlockReflection.EAST_WEST, "EAST", "WEST");
+    }
+}
diff --git a/src/test/java/org/bukkit/block/BlockRotationTest.java b/src/test/java/org/bukkit/block/BlockRotationTest.java
new file mode 100644
index 0000000..663fca4
--- /dev/null
+++ b/src/test/java/org/bukkit/block/BlockRotationTest.java
@@ -0,0 +1,52 @@
+package org.bukkit.block;
+
+import org.bukkit.Bukkit;
+import org.bukkit.geometry.Axis;
+import org.bukkit.geometry.BlockRotation;
+import org.bukkit.geometry.VectorFactory;
+import org.bukkit.support.BukkitRuntimeTest;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+public class BlockRotationTest extends BukkitRuntimeTest {
+    @Test
+    public void applyToVector() throws Exception {
+        VectorFactory V = Bukkit.vectors();
+        assertEquals(V.coarse( 0, 0,  1), BlockRotation.turns(1).transform().apply(V.coarse(1, 0, 0)));
+        assertEquals(V.coarse(-1, 0,  0), BlockRotation.turns(1).transform().apply(V.coarse(0, 0, 1)));
+        assertEquals(V.coarse( 0, 0, -1), BlockRotation.turns(1).transform().apply(V.coarse(-1, 0, 0)));
+        assertEquals(V.coarse( 1, 0,  0), BlockRotation.turns(1).transform().apply(V.coarse(0, 0, -1)));
+    }
+
+    @Test
+    public void applyToFace() throws Exception {
+        for(int turns = 1; turns < 4; turns++) {
+            for(BlockFace face : BlockFace.values()) {
+                BlockFace expected = face.isHorizontal() ? BlockFace.byBlockYaw(face.blockYaw() + turns * 4)
+                                                         : face;
+                BlockFace actual = BlockRotation.turns(turns).transform().apply(face);
+                assertEquals(expected, actual);
+            }
+        }
+    }
+
+    @Test
+    public void applytoAxis() throws Exception {
+        assertEquals(Axis.X, BlockRotation.NONE.apply(Axis.X));
+        assertEquals(Axis.Y, BlockRotation.NONE.apply(Axis.Y));
+        assertEquals(Axis.Z, BlockRotation.NONE.apply(Axis.Z));
+
+        assertEquals(Axis.Z, BlockRotation.CLOCKWISE_90.apply(Axis.X));
+        assertEquals(Axis.Y, BlockRotation.CLOCKWISE_90.apply(Axis.Y));
+        assertEquals(Axis.X, BlockRotation.CLOCKWISE_90.apply(Axis.Z));
+
+        assertEquals(Axis.X, BlockRotation.CLOCKWISE_180.apply(Axis.X));
+        assertEquals(Axis.Y, BlockRotation.CLOCKWISE_180.apply(Axis.Y));
+        assertEquals(Axis.Z, BlockRotation.CLOCKWISE_180.apply(Axis.Z));
+
+        assertEquals(Axis.Z, BlockRotation.COUNTERCLOCKWISE_90.apply(Axis.X));
+        assertEquals(Axis.Y, BlockRotation.COUNTERCLOCKWISE_90.apply(Axis.Y));
+        assertEquals(Axis.X, BlockRotation.COUNTERCLOCKWISE_90.apply(Axis.Z));
+    }
+}
diff --git a/src/test/java/org/bukkit/block/TransformTest.java b/src/test/java/org/bukkit/block/TransformTest.java
new file mode 100644
index 0000000..2ab7fa7
--- /dev/null
+++ b/src/test/java/org/bukkit/block/TransformTest.java
@@ -0,0 +1,217 @@
+package org.bukkit.block;
+
+import java.util.Random;
+
+import net.minecraft.server.BlockPosition;
+import org.bukkit.geometry.Axis;
+import org.bukkit.geometry.BlockRotoflection;
+import org.bukkit.geometry.BlockReflection;
+import org.bukkit.geometry.BlockRotation;
+import org.bukkit.geometry.CoarseTransform;
+import org.bukkit.geometry.Transform;
+import org.bukkit.geometry.Vec3;
+import org.bukkit.support.BukkitRuntimeTest;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+public class TransformTest extends BukkitRuntimeTest {
+
+    Random random = new Random();
+
+    Vec3 rand() {
+        return new BlockPosition(random.nextInt(2000) - 1000,
+                                 random.nextInt(2000) - 1000,
+                                 random.nextInt(2000) - 1000);
+    }
+
+    @Test
+    public void identity() throws Exception {
+        Vec3 p = rand();
+        assertEquals(p, Transform.identity().apply(p));
+    }
+
+    @Test
+    public void inverseIdentity() throws Exception {
+        Vec3 p = rand();
+        assertEquals(Transform.identity(), Transform.identity().inverse());
+        assertEquals(p, Transform.identity().inverse().apply(p));
+    }
+
+    @Test
+    public void compoundIdentity() throws Exception {
+        Vec3 p = rand();
+        assertEquals(Transform.identity(), Transform.identity().andThen(Transform.identity()));
+        assertEquals(Transform.identity(), Transform.identity().compose(Transform.identity()));
+        assertEquals(p, Transform.identity().andThen(Transform.identity()).apply(p));
+        assertEquals(p, Transform.identity().compose(Transform.identity()).apply(p));
+    }
+
+    @Test
+    public void translation() throws Exception {
+        Vec3 p = rand();
+        Vec3 t = rand();
+        assertEquals(p.plus(t),
+                     CoarseTransform.translation(t).apply(p));
+    }
+
+    @Test
+    public void inverseTranslation() throws Exception {
+        Vec3 p = rand();
+        Vec3 t = rand();
+        assertEquals(p.plus(t.negate()),
+                     CoarseTransform.translation(t).inverse().apply(p));
+    }
+
+    @Test
+    public void compoundTranslation() throws Exception {
+        Vec3 p = rand();
+        Vec3 t1 = rand();
+        Vec3 t2 = rand();
+
+        assertEquals(CoarseTransform.translation(t1.plus(t2)),
+                     CoarseTransform.translation(t1).andThen(CoarseTransform.translation(t2)));
+
+        assertEquals(p.plus(t1).plus(t2),
+                     CoarseTransform.translation(t1).andThen(CoarseTransform.translation(t2)).apply(p));
+
+        assertEquals(CoarseTransform.translation(t1.plus(t2)),
+                     CoarseTransform.translation(t1).compose(CoarseTransform.translation(t2)));
+    }
+
+    @Test
+    public void rotation() throws Exception {
+        Vec3 p = rand();
+        Vec3 q;
+
+        q = CoarseTransform.rotation(0).apply(p);
+        assertEquals(p, q);
+
+        q = CoarseTransform.rotation(1).apply(p);
+        assertEquals(p.coarseX(), q.coarseZ());
+        assertEquals(p.coarseY(), q.coarseY());
+        assertEquals(p.coarseZ(), -q.coarseX());
+
+        q = CoarseTransform.rotation(2).apply(p);
+        assertEquals(p.coarseX(), -q.coarseX());
+        assertEquals(p.coarseY(), q.coarseY());
+        assertEquals(p.coarseZ(), -q.coarseZ());
+
+        q = CoarseTransform.rotation(3).apply(p);
+        assertEquals(p.coarseX(), -q.coarseZ());
+        assertEquals(p.coarseY(), q.coarseY());
+        assertEquals(p.coarseZ(), q.coarseX());
+    }
+
+    @Test
+    public void negativeRotation() throws Exception {
+        Vec3 p = rand();
+
+        assertEquals(CoarseTransform.rotation(1).apply(p),
+                     CoarseTransform.rotation(1 - 4).apply(p));
+    }
+
+    @Test
+    public void wrappedRotation() throws Exception {
+        Vec3 p = rand();
+
+        assertEquals(CoarseTransform.rotation(1).apply(p),
+                     CoarseTransform.rotation(1 + 4).apply(p));
+    }
+
+    @Test
+    public void inverseRotation() throws Exception {
+        Vec3 p = rand();
+
+        assertEquals(CoarseTransform.rotation(-1).apply(p),
+                     CoarseTransform.rotation(1).inverse().apply(p));
+    }
+
+    @Test
+    public void compoundRotation() throws Exception {
+        Vec3 p = rand();
+
+        assertEquals(CoarseTransform.rotation(2).apply(p),
+                     CoarseTransform.rotation(1).andThen(CoarseTransform.rotation(1)).apply(p));
+
+        assertEquals(CoarseTransform.rotation(2).apply(p),
+                     CoarseTransform.rotation(1).compose(CoarseTransform.rotation(1)).apply(p));
+    }
+
+    @Test
+    public void compoundTransform() throws Exception {
+        Vec3 p = rand();
+        Transform t = CoarseTransform.translation(rand());
+        Transform r = CoarseTransform.rotation(random.nextInt(4));
+
+        assertEquals(t.apply(r.apply(p)),
+                     t.compose(r).apply(p));
+
+        assertEquals(r.apply(t.apply(p)),
+                     r.compose(t).apply(p));
+
+        assertEquals(r.apply(t.apply(p)),
+                     t.andThen(r).apply(p));
+
+        assertEquals(t.apply(r.apply(p)),
+                     r.andThen(t).apply(p));
+    }
+
+    @Test
+    public void manyTransforms() throws Exception {
+        Vec3 p = rand();
+        Vec3 q = p;
+        Transform a = Transform.identity();
+        Transform b = Transform.identity();
+        Transform z;
+
+        for(int i = 0; i < 10; i++) {
+            z = i % 2 == 0 ? CoarseTransform.translation(rand())
+                           : CoarseTransform.rotation(random.nextInt(4));
+
+            q = z.apply(q);
+            a = z.compose(a);
+            b = b.andThen(z);
+
+            assertEquals(q, a.apply(p));
+            assertEquals(q, b.apply(p));
+        }
+    }
+
+    @Test
+    public void detectIdentityOrientation() throws Exception {
+        assertEquals(BlockRotoflection.identity(), Transform.identity().orientation());
+    }
+
+    @Test
+    public void detectReflection() throws Exception {
+        assertEquals(BlockRotoflection.of(BlockReflection.X),
+                     CoarseTransform.reflection(Axis.X).orientation());
+
+        assertEquals(BlockRotoflection.of(BlockReflection.X, BlockRotation.CLOCKWISE_180),
+                     CoarseTransform.reflection(Axis.Z).orientation());
+
+        assertEquals(BlockRotoflection.of(BlockReflection.NONE, BlockRotation.CLOCKWISE_180),
+                     CoarseTransform.reflection(Axis.X).andThen(CoarseTransform.reflection(Axis.Z)).orientation());
+    }
+
+    @Test
+    public void detectRotation() throws Exception {
+        assertEquals(BlockRotoflection.of(BlockRotation.CLOCKWISE_90), CoarseTransform.rotation(1).orientation());
+        assertEquals(BlockRotoflection.of(BlockRotation.CLOCKWISE_180), CoarseTransform.rotation(2).orientation());
+        assertEquals(BlockRotoflection.of(BlockRotation.CLOCKWISE_270), CoarseTransform.rotation(3).orientation());
+
+        assertEquals(BlockRotoflection.of(BlockRotation.COUNTERCLOCKWISE_90), CoarseTransform.rotation(-1).orientation());
+        assertEquals(BlockRotoflection.of(BlockRotation.COUNTERCLOCKWISE_180), CoarseTransform.rotation(-2).orientation());
+        assertEquals(BlockRotoflection.of(BlockRotation.COUNTERCLOCKWISE_270), CoarseTransform.rotation(-3).orientation());
+    }
+
+    @Test
+    public void detectReflectionAndRotation() throws Exception {
+        assertEquals(BlockRotoflection.of(BlockReflection.X, BlockRotation.CLOCKWISE_90),
+                     CoarseTransform.reflection(Axis.X).andThen(CoarseTransform.rotation(1)).orientation());
+
+        assertEquals(BlockRotoflection.of(BlockReflection.Z, BlockRotation.COUNTERCLOCKWISE_90),
+                     CoarseTransform.reflection(Axis.X).andThen(CoarseTransform.rotation(1)).orientation());
+    }
+}
diff --git a/src/test/java/org/bukkit/support/BukkitRuntimeTest.java b/src/test/java/org/bukkit/support/BukkitRuntimeTest.java
new file mode 100644
index 0000000..30e5c74
--- /dev/null
+++ b/src/test/java/org/bukkit/support/BukkitRuntimeTest.java
@@ -0,0 +1,26 @@
+package org.bukkit.support;
+
+import org.bukkit.Bukkit;
+import org.bukkit.CraftBukkitRuntime;
+import org.junit.After;
+import org.junit.Before;
+
+public class BukkitRuntimeTest {
+
+    private boolean setRuntime;
+
+    @Before
+    public final void initRuntime() throws Exception {
+        setRuntime = Bukkit.getRuntime() == null;
+        if(setRuntime) {
+            CraftBukkitRuntime.load();
+        }
+    }
+
+    @After
+    public final void clearRuntime() throws Exception {
+        if(setRuntime) {
+            Bukkit.setRuntime(null);
+        }
+    }
+}
diff --git a/src/test/java/org/bukkit/util/VectorEqualityTest.java b/src/test/java/org/bukkit/util/VectorEqualityTest.java
new file mode 100644
index 0000000..aeb2260
--- /dev/null
+++ b/src/test/java/org/bukkit/util/VectorEqualityTest.java
@@ -0,0 +1,38 @@
+package org.bukkit.util;
+
+import net.minecraft.server.BlockPosition;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+public class VectorEqualityTest {
+
+    void assertMutuallyEqual(Object a, Object b) {
+        assertTrue(a + " should equal " + b, a.equals(b));
+        assertTrue(b + " should equal " + a, b.equals(a));
+
+        assertEquals(a + " and " + b + " should have identical hashCodes",
+                     a.hashCode(), b.hashCode());
+    }
+
+    void assertMutuallyUnequal(Object a, Object b) {
+        assertFalse(a + " should not equal " + b, a.equals(b));
+        assertFalse(b + " should not equal " + a, b.equals(a));
+    }
+
+    @Test
+    public void coarseEquality() throws Exception {
+        assertMutuallyEqual(new BlockPosition(1, 2, 3), new BlockVector(1, 2, 3));
+        assertMutuallyEqual(new BlockPosition(1, 2, 3), new BlockVector(1.5, 2.5, 3.5));
+    }
+
+    @Test
+    public void coarseInequality() throws Exception {
+        // Coarse vectors with different values
+        assertMutuallyUnequal(new BlockPosition(1, 2, 3), new BlockVector(4, 5, 6));
+
+        // Mix coarse and fine vectors
+        assertMutuallyUnequal(new BlockPosition(1, 2, 3), new Vector(1, 2, 3));
+        assertMutuallyUnequal(new BlockVector(1, 2, 3), new Vector(1, 2, 3));
+    }
+}
diff --git a/src/test/java/org/bukkit/util/VectorFactoryTest.java b/src/test/java/org/bukkit/util/VectorFactoryTest.java
new file mode 100644
index 0000000..c130ede
--- /dev/null
+++ b/src/test/java/org/bukkit/util/VectorFactoryTest.java
@@ -0,0 +1,59 @@
+package org.bukkit.util;
+
+import org.bukkit.Bukkit;
+import org.bukkit.geometry.Vec3;
+import org.bukkit.geometry.VectorFactory;
+import org.bukkit.support.BukkitRuntimeTest;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+public class VectorFactoryTest extends BukkitRuntimeTest {
+
+    VectorFactory V;
+
+    @Before
+    public final void initVectorFactory() throws Exception {
+        V = Bukkit.vectors();
+    }
+
+    void assertCoarse(int x, int y, int z, Vec3 v) {
+        assertTrue(v + " should be coarse", v.isCoarse());
+        assertFalse(v + " should not be fine", v.isFine());
+
+        assertEquals(x, v.coarseX());
+        assertEquals(y, v.coarseY());
+        assertEquals(z, v.coarseZ());
+    }
+
+    void assertFine(double x, double y, double z, Vec3 v) {
+        assertTrue(v + " should be fine", v.isFine());
+        assertFalse(v + " should not be coarse", v.isCoarse());
+
+        assertEquals(x, v.fineX(), 0D);
+        assertEquals(y, v.fineY(), 0D);
+        assertEquals(z, v.fineZ(), 0D);
+    }
+
+    @Test
+    public void immutable() throws Exception {
+        assertCoarse(1, 2, 3, V.coarse(1, 2, 3));
+        assertCoarse(0, 0, 0, V.coarseZero());
+        assertFine(1.5, 2.5, 3.5, V.fine(1.5, 2.5, 3.5));
+        assertFine(0, 0, 0, V.fineZero());
+    }
+
+    @Test
+    public void mutable() throws Exception {
+        Vec3 v;
+
+        v = V.coarseMutable(1, 2, 3);
+        assertCoarse(1, 2, 3, v);
+        assertTrue(v.isMutable());
+
+        v = V.fineMutable(1.5, 2.5, 3.5);
+        assertFine(1.5, 2.5, 3.5, v);
+        assertTrue(v.isMutable());
+    }
+}
diff --git a/src/test/java/org/bukkit/util/VectorMixedResolutionArithmeticTest.java b/src/test/java/org/bukkit/util/VectorMixedResolutionArithmeticTest.java
new file mode 100644
index 0000000..9da3b8e
--- /dev/null
+++ b/src/test/java/org/bukkit/util/VectorMixedResolutionArithmeticTest.java
@@ -0,0 +1,55 @@
+package org.bukkit.util;
+
+import org.bukkit.Bukkit;
+import org.bukkit.geometry.Vec3;
+import org.bukkit.geometry.VectorFactory;
+import org.bukkit.support.BukkitRuntimeTest;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+public class VectorMixedResolutionArithmeticTest extends BukkitRuntimeTest {
+
+    VectorFactory V;
+
+    @Before
+    public void setUp() throws Exception {
+        V = Bukkit.vectors();
+    }
+
+    @Test
+    public void addLessThanOne() throws Exception {
+        final Vec3 v = V.coarse(1, 2, 3);
+        assertEquals(v, v.plus(0.5));
+        assertEquals(v.minus(1), v.plus(-0.5));
+        assertEquals(v.minus(1), v.minus(0.5));
+        assertEquals(v, v.minus(-0.5));
+
+        assertEquals(v, v.mutableCopy().add(0.5));
+        assertEquals(v.minus(1), v.mutableCopy().add(-0.5));
+        assertEquals(v.minus(1), v.mutableCopy().subtract(0.5));
+        assertEquals(v, v.mutableCopy().subtract(-0.5));
+    }
+
+    @Test
+    public void addMoreThanOne() throws Exception {
+        final Vec3 v = V.coarse(1, 2, 3);
+        assertEquals(v.plus(1), v.plus(1.5));
+        assertEquals(v.minus(2), v.plus(-1.5));
+        assertEquals(v.minus(2), v.minus(1.5));
+        assertEquals(v.plus(1), v.minus(-1.5));
+
+        assertEquals(v.plus(1), v.mutableCopy().add(1.5));
+        assertEquals(v.minus(2), v.mutableCopy().add(-1.5));
+        assertEquals(v.minus(2), v.mutableCopy().subtract(1.5));
+        assertEquals(v.plus(1), v.mutableCopy().subtract(-1.5));
+    }
+
+    @Test
+    public void multiply() throws Exception {
+        final Vec3 v = V.coarse(100, 200, 300);
+        assertEquals(V.coarse(50, 100, 150), v.times(0.5));
+        assertEquals(V.coarse(-50, -100, -150), v.times(-0.5));
+    }
+}
-- 
1.9.0

